# üåå Conditional Branching

## If statement
+ The `if(...)` statement evaluates a condition in parentheses and `if` statements don't just work with true or false values. They evaluate truthy or falsy values.
+ evaluates the expression in its parentheses and converts the result to a Boolean. 
	+ If the expression evaluates to a truthy value, the if block executes.
	+ If it evaluates to a falsy value, it moves to the else if or else block (if provided).
+ if statements are evaluated sequentially from top to bottom.
	+ If a condition is met, the corresponding block executes, and the remaining conditions are skipped
+ Scope
	+ the variables declared inside an if block are scoped to that block.

```js
let year = prompt('In which year was the ECMAScript-2015 specification published?', '');

if (year < 2015) {
  alert( 'Too early...' );
} else if (year > 2015) {
  alert( 'Too late' );
} else {
  alert( 'Exactly!' );
}
```

```js
if (true) {
    let a = 10; // Scoped to this block
}
console.log(a); // ReferenceError: a is not defined
```
## Conditional operator ‚Äò?‚Äô
+ represented by a question mark¬†`?`. Sometimes it‚Äôs called ‚Äúternary‚Äù, because the operator has three operands.
	+ the one and only operator in JavaScript which has that many
+ Assign a variable depending on a condition
+ The question mark operator has a low precedence
	+ we can omit the parentheses
```js
// syntax
let result = condition ? value1 : value2;

// sample
let accessAllowed = (age > 18) ? true : false;
let accessAllowed = age > 18 ? true : false;
let accessAllowed = age > 18; // avoiding ?

// multiple condition
let message = (age < 3) ? 'Hi, baby!' :
  (age < 18) ? 'Hello!' :
  (age < 100) ? 'Greetings!' :
  'What an unusual age!';
```
	
+ Non-traditional use of ‚Äò?‚Äô
	+ used as a replacement for if - not recommended
```js
let company = prompt('Which company created JavaScript?', '');

(company == 'Netscape') ?
   alert('Right!') : alert('Wrong.');
```

>[!NOTE]
>The purpose of the question mark operator ? is to return one value or another depending on its condition. Please use it for exactly that. Use if when you need to execute different branches of code

## Switch statement
+ __Syntax__
	+ one or more _cases_, _optional_ default
	+  common convention to place the _default_ case at the end
		+ placement of default is not strictly enforced by the language
	+ checked for a _strict equality_ against cases
		+ values must be of the same type to match
	```js 
	switch(x) {  //strict equality
	  case 'value1':  // if (x === 'value1')
	    ...
	    [break]
	
	  case 'value2':  // if (x === 'value2')
	    ...
	    [break]
	
	  default:
	    ...
	    [break]
	}
	```
	
	```js
	let arg = prompt("Enter a value?");
	switch (arg) {
	  case '0':
	  case '1':
	    alert( 'One or zero' );
	    break;
	
	  case '2':
	    alert( 'Two' );
	    break;
	
	  case 3:
	    alert( 'Never executes!' );
	    break;
	  default:
	    alert( 'An unknown value' );
	}

	// if given '3'
	// case 3 will not execute
	```

+ __Behavior__ (generated by gpt)
	+ No Match? Default!: If no matching case is found, JavaScript executes the default case (if provided).
	+ Fall-through Behavior: Once a match is found, JavaScript executes the code in that case and continues executing subsequent cases until a break statement is encountered, regardless of whether those cases match the expression value.
	+ The break Statement: The break acts like a "stop execution" command, preventing further cases from being executed and exiting the switch block.
	+ One Match Stops Further Checking: If a match is found for an earlier case, the later case labels are not evaluated, even if they also match the expression value.
	+ Sequential Illusion: While the switch may appear to perform sequential checks, conceptually, it jumps directly to the first matching case or default. This is especially true in modern JavaScript engines, which optimize switch for performance using techniques like jump tables or hash maps.

+ __Fall-through__
	+ If there is no break then the execution continues with the next case _without any checks_
	+ If break is omitted, execution will proceed to the next case clause, even to the default clause, regardless of whether the value of that clause's expression matches. This behavior is called "_fall-through_"
	```js
	let a = 2 + 2;
	
	switch (a) {
	  case 3:
	    alert( 'Too small' );
	  case 4:
	    alert( 'Exactly!' );
	  case 5:
	    alert( 'Too big' );
	  default:
	    alert( "I don't know such values" );
	}
	
	// 'Exactly'
	// 'Too big'
	// 'I don't know such values'
	```

	```js
	let value = 5;

	switch (value) {
	    case 1:
	        console.log("Case 1");
	        break;
	    default:
	        console.log("Default case"); // no break so fall-through
	    case 6:
	        console.log("Case 6");
	}

	// Output
	// Default case 
	// Case 6
	```

+ __Grouping Cases__
	+ The ability to ‚Äúgroup‚Äù cases is a side effect of how¬†`switch/case`¬†works without¬†`break`
	```js
	let a = 3;

	switch (a) {
	  case 4:
	    alert('Right!');
	    break;
	
	  case 3: // (*) grouped two cases
	  case 5:
	    alert('Wrong!');
	    alert("Why don't you take a math class?");
	    break;
	
	  default:
	    alert('The result is strange. Really.');
	}
	```

+ __Position of `default`__
	+ JS will jump to the default case regardless of its position in the switch statement. After executing the default case, the flow will continue to subsequent cases unless interrupted by a break.
	```js
	let value = 5;
	
	switch (value) {
	    default:
	        console.log("Default case");
	        break;
	    case 1:
	        console.log("Case 1");
	        break;
	    case 2:
	        console.log("Case 2");
	        break;
	}
	
	// Default case
	```

	```js
	let value = 5;
	
	switch (value) {
	    case 1:
	        console.log("Case 1");
	        break;
	    case 2:
	        console.log("Case 2");
	        break;
	    default:
	        console.log("Default case");
	    case 3:
	        console.log("Case 3");
	        break;
	}
	
	//Default case
	// Case 3
	```

+ **Reasons to use a¬†`default`**
	1. To 'catch' an unexpected value or when another case gets added at the end _(defensive programming)_
	2. To handle 'default' actions, where the cases are for special behavior
	3. Good practice

+ __Under the hood__ (generated by gpt)
	+ If you think about it as a series of checks, it looks like sequential evaluation. This is how many tutorials explain switch, but this is not how modern engines implement it under the hood
	+ Modern JavaScript engines prioritize performance and will use non-sequential optimizations (e.g., jump tables or hash maps) when possible. JavaScript engines like V8, SpiderMonkey, and JavaScriptCore often do not check cases sequentially. Instead, they optimize the switch depending on the situation:
		+ Simple case values (e.g., numbers or strings): The engine uses a jump table or a similar structure, allowing it to "jump" directly to the matching case without sequential checks
		+ Complex cases (e.g., ranges or computed expressions): The engine might revert to sequential checks because such cases can't be precomputed into an optimized structure.
		```js
		// The first three cases could be optimized into a jump table.
		// The Math.random() case forces a sequential check because the value is evaluated dynamically.
		
			switch (value) {
		    case 1: // Direct match
		    case 100: // Direct match
		    case 200: // Direct match
		    case Math.random(): // Requires sequential checks (dynamic value)
			}
		```
	+ What Should You Remember?
		+ Logically: It feels like switch checks sequentially because the case labels are written in a specific order.
		+ Internally: For simple cases, engines optimize for speed (e.g., jump tables). For complex or sparse cases, engines may fall back to sequential checks.

+ Mental model change ??
	+ switch 
		+ checking 1 variable/expression
		+ strict equality for checking
		+ fall-through without any checks
		+ may use sequential, jump table, etc. depending on engine optimization
		+ The position of default does not matter‚Äîexecution will jump to it if no case matches